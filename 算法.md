# 算法

- 算法非常复杂，发展也很多年了。有空多练练，思维是需要训练的。

## 常用算法的时间复杂度

- 时间复杂度是算法的重要指标，是重要的优化指标；常用的算法都有参考标准。也是优化的目标。

1、比较算法，求最小最大 O(n)

2、排序算法，nlogn

3、树，dfs，bfs ，O(n)

4、图，O(V+E)

5、动态规划，O(nm)

### 时间复杂度及举例

一、O(1)

常见算法：数组随机存取、固定大小的循环、获取链表的长度或头尾节点、简单算术运算或位运算（+、-、*、/、&、|、~、^）、哈希散列表查找（unordered_map、unordered_set）

数组随机存取：数组具有

二、O(logn)

表示log2n

常见算法：for或while以i*2或i/2进行变化、二分查找、平衡二叉树查找（map、set）、分治算法

三、O(n)

常见算法：线性查找、以变量为迭代指标遍历、求和、计数、拷贝、阶乘算法、链表合并（max(m,n)）、计数排序、桶排序、广度优先搜索算法、深度优先搜索算法

四、O(nlogn)

常见算法：堆排序、快速排序、归并排序、希尔排序、计数排序、基数排序、C+±std::sort()

堆排序：大根堆、小根堆，属于二叉排序树/二叉搜索树/二叉查找树

快速排序：自上而下将数据进行分治

归并排序：自下而上将数据分治为小粒度，再进行合并

1、常用的数据结构有哪些？都有什么特性

数组，二叉树，大小堆，栈，链表，领接表，边列表，领接矩阵，

2、常用算法的时间复杂度

比较算法，o(nlogn)

求最大值，o(n)

二分查找,二叉树查找，分治算法，o(logn)

计数，基数，桶排序，o(n+k)

## 算法

1、最小生成树（MST）:最小生成树（Minimum Spanning Tree，MST）是指在一个连通的带权无向图中，包含所有顶点且边权之和最小的树。最小生成树与子图的最小生成树存在着紧密的联系

2、最小生成树的性质：权值最小性、无环性、连通性、唯一性不一定成立

3、常用的方法来找到最小生成树包括：

- 1. **普里姆算法（Prim's Algorithm）**：从一个起始顶点开始，逐步扩展生成最小生成树，每次选择连接已经选择的顶点和未选择的顶点的最短边。该算法将生成树逐渐扩展，直到包含所有顶点为止。
- 2. **克鲁斯卡尔算法（Kruskal's Algorithm）**：将所有边按照权重从小到大排序，逐个加入生成树中，加入的边不能形成环路，直到生成树包含了所有的顶点。该算法适用于稀疏图（边的数量远小于顶点的数量）。

   这两种方法都能够找到最小生成树，选择使用哪种方法取决于具体的应用场景和图的特性。普里姆算法适用于稠密图（边的数量接近顶点的数量）和连接矩阵表示图的情况下，而克鲁斯卡尔算法适用于稀疏图和边集合表示图的情况下。

- 3、除了这两种经典算法外，还有其他一些算法可以用来找到最小生成树，例如：

    -**Boruvka算法**：采用分而治之的策略，在每一次迭代中选择连接各个连通分量的最小边，直到只剩下一个连通分量为止。
    - **加权并查集算法**：利用并查集数据结构来动态地维护连通性，并根据边的权重逐步选择生成最小生成树的边。

   这些方法在不同的情况下有不同的效果和适用性，具体使用哪种方法需要根据实际问题和图的性质进行选择。

4、增广路径、最大流问题，Ford-Fulkerson算法实现过程的理解和掌握：

   在网络流中，增广路径指的是一条从源点到汇点的路径，并且该路径上的流量可以被增加。通过不断寻找增广路径，并增加路径上的流量，我们可以得到最大流量。而最大流问题就是要找到一种在网络中流动最大流量的方法。

   Ford-Fulkerson算法是一种求解最大流问题的经典算法，其实现过程如下：

    - 1. 初始化一个流量为0的流网络，并令残量网络等于原始网络。
    - 2. 找到一条增广路径。可以使用任何常用的图遍历算法来找到增广路径，例如广度优先搜索（BFS）或深度优先搜索（DFS）。找到增广路径后，计算该路径上的最小残量容量，这个最小残量容量就是当前增广路径的流量增加量。
    - 3. 增加即将流过该增广路径的流量。为增加流量，可以按下面的方式更新流量和残量网络:

    a) 对于增广路径上的每条正向边，增加相应的流量，并扣减该边所连的节点之间的残量。

    b) 对于增广路径上的每条反向边，减少相应的流量，并增加该边所连的节点之间的残量。
    - 4. 重复步骤2和3，直到找不到增广路径为止。这个时候，我们可以确定已经得到了最大流。

    需要注意的是，Ford-Fulkerson算法的实现需要满足以下两个条件：

    - 残量网络必须能够找到增广路径。也就是说，我们必须保证每个可行流中都存在增广路径。
      - 在每一次增加流量时必须要保证新增的流量是合法的。也就是说，我们必须确保新增的流量不会超过任意一条边的容量。

   总的来说，Ford-Fulkerson算法是一个非常经典的求解最大流问题的算法。主要思想是不断地寻找增广路径，然后增加沿该路径流过的流量，直到找不到增广路径为止，从而得到最大流。

5、Dominating Set Problem支配集问题

支配集问题是图论中的一个基本问题，通常又称为“支配集问题”、“控制集问题”或“统治集问题”。在给定无向图$G=(V,E)$和一个整数$k$的情况下，支配集问题要求找到一个大小为$k$的顶点子集$S\subseteq V$，使得图中的每个顶点要么属于$S$，要么与$S$中某个节点相邻。这样的一个$k$大小的顶点集合$S$被称为一个$k$支配集。

支配集问题很重要，因为支配集可以用于寻找网络中最小的容量，如网络传输控制协议（TCP）中的拥塞控制问题。此外，支配集问题还可以用于设计并行算法以及图形设计和布局。

支配集问题被证明是一个NP-hard问题，因此没有已知的快速算法可以完全解决它，但是在某些情况下可以使用近似算法或启发式算法来解决它。

6、NP-Complete问题

NP-Complete问题是计算机科学中的一类问题，是指具有两个性质的问题：1. 它们属于NP问题类，即可以在多项式时间内验证一个给定解的正确性；2. 任何一个NP问题都可以在多项式时间内约化为它，即可以用它来模拟其他的NP问题。

NP-Complete问题是非常重要的，因为如果能够找到一个多项式时间的算法来解决任何一个NP-Complete问题，那么就可以解决所有NP问题。换句话说，NP-Complete问题被认为是最困难的NP问题。

一些著名的NP-Complete问题包括旅行商问题（TSP）、背包问题（Knapsack）、图的着色问题（Graph Coloring）、子集和问题（Subset Sum）等。这些问题在许多实际应用中都是很重要的，例如在旅行、资源分配、排程和网络优化等领域中。

由于NP-Complete问题的困难性质，通常没有已知的有效算法可以在多项式时间内解决它们。所以在实际应用中，常常使用近似算法、启发式算法或者限制问题规模来快速求解NP-Complete问题。

7、3-SAT问题

3-SAT问题是一类著名的布尔可满足性问题（SAT问题）的特例。在3-SAT问题中，给定一个由布尔变量和逻辑运算符（与、或和非）组成的布尔表达式，问题是判断是否存在一组布尔变量的赋值，使得整个表达式为真。

3-SAT问题的具体形式是，给定一个包含多个子句的合取范式（CNF）表达式，其中每个子句包含上至多3个文字（变量或其否定），且每个文字都和其他文字通过逻辑或进行连接。问题是要确定是否存在一组变量的赋值，使得整个CNF表达式中的每个子句至少有一个文字为真。

3-SAT问题是一个典型的NP-Complete问题，这意味着如果能够在多项式时间内解决3-SAT问题，那么可以解决所有NP问题。由于3-SAT问题的困难性质，目前并没有已知的快速算法能够在多项式时间内解决一般的3-SAT问题。因此，研究者通常使用启发式算法、近似算法或其他特定的技术来处理实际问题中的3-SAT实例。

8、Dominating Set Problem支配集问题、NP-Complete问题、3-SAT问题、三者间的关系证明

支配集问题、3-SAT问题都是NP-Complete问题的典型代表，也就是说，它们可以归约为任何一个NP问题，而且彼此之间也可以相互归约。具体来说，我们可以把3-SAT问题约化为支配集问题，反之也可以将支配集问题约化为3-SAT问题。

以将3-SAT问题约化为支配集问题为例，我们可以构造一个图，让图的节点表示布尔表达式中的每个文字，对于每个子句，我们都可以构造一个大小为3的点集，其中包含三个文字所对应的节点，然后让这三个点之间互相连边，表示三个文字中至少有一个为真的关系。对于每个节点，我们还可以连一条自环边，表示该节点为真或者假的情况。

这样构造出来的图就是支配集问题所需要的图，我们只需要在该图中找到一个大小为k的支配集，就相当于找到了一个满足3-SAT问题的解，从而证明了支配集问题与3-SAT问题的等价性。

因此，可以说支配集问题、NP-Complete问题、3-SAT问题都是复杂性理论中的经典问题，它们在计算机科学和其他领域中都具有广泛的应用。

9、有向无环图、DFS、回边、横跨边

有向无环图（Directed Acyclic Graph，简称DAG）是一种图结构，它由一组节点和有向边组成，且不存在任何环路路径。这意味着在DAG中，从任何一个节点开始，通过有向边只能到达其他节点，而不能回到或经过已经访问过的节点。

深度优先搜索（Depth-First Search，简称DFS）是一种用于遍历图或树的算法。在DFS中，从一个节点开始，沿着一个路径尽可能到达深处，直到无法继续前进时，回溯并探索其他路径。DFS使用栈或递归函数来保存当前节点的状态，以便能够回溯到上一个节点。

回边（Back Edge）是指在有向图或无向图的DFS过程中，指向已经访问过的祖先节点的边。回边表示图中存在环路，因为在DFS过程中，如果遇到回边，说明乘坐该边可以回到之前访问过的节点，形成了环路。

横跨边（Cross Edge）是指在有向图或无向图的DFS过程中，指向非祖先节点的边。横跨边不会形成环路，因为它指向的节点不是当前节点的祖先节点。

总结起来，在有向图的DFS过程中，回边表示存在环路，横跨边则不会形成环路。在有向无环图（DAG）中，不会存在回边，但可能存在横跨边。而在无向图的DFS过程中，只会存在回边，不会存在横跨边。

10、DFS完成数的概念、DFS的回溯性质

DFS完成数，也称作DFS完成时间，是指在深度优先搜索（DFS）过程中，每个节点第一次被标记为"完成"的时间戳。它可以用来判断节点在DFS中的相对位置以及与其他节点之间的关系。

在DFS中，每个节点有三个时间戳属性：发现时间（discovery time）、完成时间（finish time）和探索状态。发现时间表示节点第一次被探索的时间，而完成时间表示节点完成所有可能的探索并回溯的时间。DFS完成数是根据节点的完成时间来进行排序的，完成时间越早，DFS完成数越小。具体来说，如果节点A的完成时间早于节点B的完成时间，那么节点A的DFS完成数就小于节点B的DFS完成数。

DFS的回溯性质是指在DFS过程中，当遍历完一个节点的所有相邻节点后，将会回溯到上一个节点，再继续遍历其他未访问的相邻节点。这种回溯的过程，保证了DFS能够遍历图中所有的节点。同时，通过回溯，可以避免重复访问已经访问过的节点，并且能够发现环路。

DFS的回溯性质使得它在解决许多图算法问题中非常有用，例如拓扑排序、寻找强连通分量、判定图的连通性等。通过DFS的回溯性质，我们可以控制搜索的方向以及确保每个节点都被遍历到，从而实现对图结构的全面探索。

11. 找一个最长加权简单路径的动态规划的方法；

   找一个最长加权简单路径可以使用动态规划的方法来解决。下面给出一种基于动态规划的算法：

   1). 首先，定义一个数组DP，用来保存每个节点的最长加权简单路径的长度。
   2). 初始化DP数组，将每个节点的最长加权简单路径长度都设置为负无穷（表示无穷远）。
   3). 选择一个起始节点。
   4). 对于起始节点，将其最长加权简单路径长度设置为0，表示到达起始节点的路径长度为0。
   5). 从起始节点开始，按照拓扑排序的顺序遍历每个节点。
   6). 对于当前遍历到的节点v，遍历其所有的入边，并计算以每条入边的起始节点u为结尾的路径的总权重值。如果该路径的权重加上节点u的DP值大于节点v的DP值，则将节点v的DP值更新为该路径的权重加上节点u的DP值。
   7). 重复步骤6，直到遍历完所有的节点。
   8). 最终，DP数组中的最大值就是整个图中最长加权简单路径的长度。

   这个动态规划算法的时间复杂度是O(V+E)，V表示节点的个数，E表示边的个数。通过动态规划的思路，我们可以在图中找到最长的加权简单路径。需要注意的是，使用这种方法前提是图中不能存在环路，因为环路会导致无穷加权路径的存在，使得找到最长路径变得不可能。

## 参考文献：

1、[编程竞赛文档](https://github.com/OI-wiki/OI-wiki)

2、[十大经典排序算法](http://www.runoob.com/w3cnote/ten-sorting-algorithm.html)

3、[算法4代码](https://github.com/GenoWong/IntroductionToAlgorithms)
4、[算法3代码](https://github.com/walkccc/CLRS)
5、[算法4官网](https://mitpress.mit.edu/9780262046305/introduction-to-algorithms/)
